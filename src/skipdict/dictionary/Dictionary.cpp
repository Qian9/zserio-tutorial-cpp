/**
 * Automatically generated by Zserio C++ extension version 1.0.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include "skipdict/dictionary/SkippableDictionary.h"

namespace skipdict
{
namespace dictionary
{

namespace
{
class _offsetChecker_entries
{
public:
    explicit _offsetChecker_entries(SkippableDictionary& owner) : m_owner(owner) {}

    void checkOffset(size_t _index, size_t byteOffset) const
    {
        if (byteOffset != m_owner.getOffsets().at(_index))
            throw zserio::CppRuntimeException("Wrong offset for field SkippableDictionary.entries: " +
                    zserio::convertToString(byteOffset) + " != " +
                    zserio::convertToString(m_owner.getOffsets().at(_index)) + "!");
    }

private:
    SkippableDictionary& m_owner;
};

class _offsetSetter_entries
{
public:
    explicit _offsetSetter_entries(SkippableDictionary& owner) : m_owner(owner) {}

    void setOffset(size_t _index, size_t byteOffset) const
    {
        const uint32_t _value = (uint32_t)byteOffset;
        m_owner.getOffsets().at(_index) = _value;
    }

private:
    SkippableDictionary& m_owner;
};

class _elementFactory_SkippableDictionary_entries
{
public:
    explicit _elementFactory_SkippableDictionary_entries(SkippableDictionary& owner) : m_owner(owner) {}

    void create(void* storage, zserio::BitStreamReader& _in, size_t _index)
    {
        (void)_index;
        new (storage) skipdict::dictionary::DictEntry(_in);
    }

private:
    SkippableDictionary& m_owner;
};

} // namespace

SkippableDictionary::SkippableDictionary()
{
}

SkippableDictionary::SkippableDictionary(zserio::BitStreamReader& _in)
{
    read(_in);
}

zserio::UInt32Array& SkippableDictionary::getOffsets()
{
    return m_offsets;
}

const zserio::UInt32Array& SkippableDictionary::getOffsets() const
{
    return m_offsets;
}

void SkippableDictionary::setOffsets(const zserio::UInt32Array& offsets)
{
    m_offsets = offsets;
}

zserio::ObjectArray<skipdict::dictionary::DictEntry>& SkippableDictionary::getEntries()
{
    return m_entries;
}

const zserio::ObjectArray<skipdict::dictionary::DictEntry>& SkippableDictionary::getEntries() const
{
    return m_entries;
}

void SkippableDictionary::setEntries(const zserio::ObjectArray<skipdict::dictionary::DictEntry>& entries)
{
    m_entries = entries;
}

size_t SkippableDictionary::bitSizeOf(size_t _bitPosition) const
{
    size_t _endBitPosition = _bitPosition;

    _endBitPosition += m_offsets.bitSizeOf(_endBitPosition, zserio::AutoLength(), UINT8_C(32));
    if (getEntries().size() > 0)
        _endBitPosition = zserio::alignTo(zserio::NUM_BITS_PER_BYTE, _endBitPosition);
    _endBitPosition += m_entries.bitSizeOf(_endBitPosition, zserio::AutoLength(), zserio::Aligned());

    return _endBitPosition - _bitPosition;
}

size_t SkippableDictionary::initializeOffsets(size_t _bitPosition)
{
    size_t _endBitPosition = _bitPosition;

    _endBitPosition = m_offsets.initializeOffsets(_endBitPosition, zserio::AutoLength(), UINT8_C(32));
    if (getEntries().size() > 0)
        _endBitPosition = zserio::alignTo(zserio::NUM_BITS_PER_BYTE, _endBitPosition);
    _endBitPosition = m_entries.initializeOffsets(_endBitPosition, zserio::AutoLength(), _offsetSetter_entries(*this));

    return _endBitPosition;
}

bool SkippableDictionary::operator==(const SkippableDictionary& _other) const
{
    if (this != &_other)
    {
        return
                (m_offsets == _other.m_offsets) &&
                (m_entries == _other.m_entries);
    }

    return true;
}

int SkippableDictionary::hashCode() const
{
    int _result = zserio::HASH_SEED;

    _result = zserio::calcHashCode(_result, m_offsets);
    _result = zserio::calcHashCode(_result, m_entries);

    return _result;
}

void SkippableDictionary::read(zserio::BitStreamReader& _in)
{
    m_offsets.read(_in, zserio::AutoLength(), UINT8_C(32));
    m_entries.read(_in, zserio::AutoLength(), _elementFactory_SkippableDictionary_entries(*this), _offsetChecker_entries(*this));
}

void SkippableDictionary::write(zserio::BitStreamWriter& _out, zserio::PreWriteAction _preWriteAction)
{
    if ((_preWriteAction & zserio::PRE_WRITE_INITIALIZE_OFFSETS) != 0)
        initializeOffsets(_out.getBitPosition());

    m_offsets.write(_out, zserio::AutoLength(), UINT8_C(32));
    m_entries.write(_out, zserio::AutoLength(), _offsetChecker_entries(*this));
}

} // namespace dictionary
} // namespace skipdict

/**
 * Automatically generated by Zserio C++ extension version 1.0.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include "skipdict/dictionary/DictEntry.h"

namespace skipdict
{
namespace dictionary
{

DictEntry::DictEntry()
{
    m_typeCode = uint8_t();
}

DictEntry::DictEntry(zserio::BitStreamReader& _in)
{
    read(_in);
}

uint8_t DictEntry::getTypeCode() const
{
    return m_typeCode;
}

void DictEntry::setTypeCode(uint8_t typeCode)
{
    m_typeCode = typeCode;
}

zserio::UInt8Array& DictEntry::getValue()
{
    return m_value;
}

const zserio::UInt8Array& DictEntry::getValue() const
{
    return m_value;
}

void DictEntry::setValue(const zserio::UInt8Array& value)
{
    m_value = value;
}

size_t DictEntry::bitSizeOf(size_t _bitPosition) const
{
    size_t _endBitPosition = _bitPosition;

    _endBitPosition += UINT8_C(8);
    _endBitPosition += m_value.bitSizeOf(_endBitPosition, zserio::AutoLength(), UINT8_C(8));

    return _endBitPosition - _bitPosition;
}

size_t DictEntry::initializeOffsets(size_t _bitPosition)
{
    size_t _endBitPosition = _bitPosition;

    _endBitPosition += UINT8_C(8);
    _endBitPosition = m_value.initializeOffsets(_endBitPosition, zserio::AutoLength(), UINT8_C(8));

    return _endBitPosition;
}

bool DictEntry::operator==(const DictEntry& _other) const
{
    if (this != &_other)
    {
        return
                (m_typeCode == _other.m_typeCode) &&
                (m_value == _other.m_value);
    }

    return true;
}

int DictEntry::hashCode() const
{
    int _result = zserio::HASH_SEED;

    _result = zserio::calcHashCode(_result, m_typeCode);
    _result = zserio::calcHashCode(_result, m_value);

    return _result;
}

void DictEntry::read(zserio::BitStreamReader& _in)
{
    m_typeCode = (uint8_t)_in.readBits(UINT8_C(8));
    m_value.read(_in, zserio::AutoLength(), UINT8_C(8));
}

void DictEntry::write(zserio::BitStreamWriter& _out, zserio::PreWriteAction)
{
    _out.writeBits(m_typeCode, UINT8_C(8));
    m_value.write(_out, zserio::AutoLength(), UINT8_C(8));
}

} // namespace dictionary
} // namespace skipdict

/**
 * Automatically generated by Zserio C++ extension version 1.0.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include "skipdict/dictionary/DictOffsets.h"

namespace skipdict
{
namespace dictionary
{

DictOffsets::DictOffsets()
{
}

DictOffsets::DictOffsets(zserio::BitStreamReader& _in)
{
    read(_in);
}

zserio::UInt32Array& DictOffsets::getOffsets()
{
    return m_offsets;
}

const zserio::UInt32Array& DictOffsets::getOffsets() const
{
    return m_offsets;
}

void DictOffsets::setOffsets(const zserio::UInt32Array& offsets)
{
    m_offsets = offsets;
}

size_t DictOffsets::bitSizeOf(size_t _bitPosition) const
{
    size_t _endBitPosition = _bitPosition;

    _endBitPosition += m_offsets.bitSizeOf(_endBitPosition, zserio::AutoLength(), UINT8_C(32));

    return _endBitPosition - _bitPosition;
}

size_t DictOffsets::initializeOffsets(size_t _bitPosition)
{
    size_t _endBitPosition = _bitPosition;

    _endBitPosition = m_offsets.initializeOffsets(_endBitPosition, zserio::AutoLength(), UINT8_C(32));

    return _endBitPosition;
}

bool DictOffsets::operator==(const DictOffsets& _other) const
{
    if (this != &_other)
    {
        return
                (m_offsets == _other.m_offsets);
    }

    return true;
}

int DictOffsets::hashCode() const
{
    int _result = zserio::HASH_SEED;

    _result = zserio::calcHashCode(_result, m_offsets);

    return _result;
}

void DictOffsets::read(zserio::BitStreamReader& _in)
{
    m_offsets.read(_in, zserio::AutoLength(), UINT8_C(32));
}

void DictOffsets::write(zserio::BitStreamWriter& _out, zserio::PreWriteAction)
{
    m_offsets.write(_out, zserio::AutoLength(), UINT8_C(32));
}

} // namespace dictionary
} // namespace skipdict
