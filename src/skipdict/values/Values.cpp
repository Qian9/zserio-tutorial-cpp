/**
 * Automatically generated by Zserio C++ extension version 1.0.
 */

#include <zserio/BitSizeOfCalculator.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/StringConvertUtil.h>

#include "skipdict/values/ValueCode.h"

namespace skipdict
{
namespace values
{

ValueCode::ValueCode() : m_value(static_cast<e_ValueCode>(0))
{
}

ValueCode::ValueCode(e_ValueCode value) : m_value(value)
{
}

ValueCode::ValueCode(zserio::BitStreamReader& _in)
{
    read(_in);
}

ValueCode::operator e_ValueCode() const
{
    return m_value;
}

uint8_t ValueCode::getValue() const
{
    return m_value;
}

size_t ValueCode::bitSizeOf(size_t) const
{
    return UINT8_C(8);
}

size_t ValueCode::initializeOffsets(size_t _bitPosition) const
{
    return _bitPosition + bitSizeOf(_bitPosition);
}

bool ValueCode::operator==(const ValueCode& other) const
{
    return m_value == other.m_value;
}

bool ValueCode::operator==(e_ValueCode other) const
{
    return m_value == other;
}

int ValueCode::hashCode() const
{
    return zserio::calcHashCode(zserio::HASH_SEED, static_cast<uint8_t>(m_value));
}

void ValueCode::read(zserio::BitStreamReader& _in)
{
    m_value = toEnum(_in.readBits(UINT8_C(8)));
}

void ValueCode::write(zserio::BitStreamWriter& _out, zserio::PreWriteAction) const
{
    _out.writeBits(static_cast<uint8_t>(m_value), UINT8_C(8));
}

const char* ValueCode::toString() const
{
    switch (m_value)
    {
    case COMPANY:
        return "COMPANY";
    case ROCK_BAND:
        return "ROCK_BAND";
    case BASKETBALL_TEAM:
        return "BASKETBALL_TEAM";
    case CLOUD_STORAGE:
        return "CLOUD_STORAGE";
    default:
        return "UNKNOWN";
    }
}

ValueCode ValueCode::toEnum(uint8_t rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
        return COMPANY;

    case UINT8_C(1):
        return ROCK_BAND;

    case UINT8_C(2):
        return BASKETBALL_TEAM;

    case UINT8_C(3):
        return CLOUD_STORAGE;

    default:
        throw zserio::CppRuntimeException("Unknown value for enumeration ValueCode: " +
                zserio::convertToString(rawValue) + "!");
    }
}

} // namespace values
} // namespace skipdict

/**
 * Automatically generated by Zserio C++ extension version 1.0.
 */

#include <zserio/BitSizeOfCalculator.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/StringConvertUtil.h>

#include "skipdict/values/CloudStorage.h"

namespace skipdict
{
namespace values
{

CloudStorage::CloudStorage() : m_value(static_cast<e_CloudStorage>(0))
{
}

CloudStorage::CloudStorage(e_CloudStorage value) : m_value(value)
{
}

CloudStorage::CloudStorage(zserio::BitStreamReader& _in)
{
    read(_in);
}

CloudStorage::operator e_CloudStorage() const
{
    return m_value;
}

uint8_t CloudStorage::getValue() const
{
    return m_value;
}

size_t CloudStorage::bitSizeOf(size_t) const
{
    return UINT8_C(3);
}

size_t CloudStorage::initializeOffsets(size_t _bitPosition) const
{
    return _bitPosition + bitSizeOf(_bitPosition);
}

bool CloudStorage::operator==(const CloudStorage& other) const
{
    return m_value == other.m_value;
}

bool CloudStorage::operator==(e_CloudStorage other) const
{
    return m_value == other;
}

int CloudStorage::hashCode() const
{
    return zserio::calcHashCode(zserio::HASH_SEED, static_cast<uint8_t>(m_value));
}

void CloudStorage::read(zserio::BitStreamReader& _in)
{
    m_value = toEnum(_in.readBits(3));
}

void CloudStorage::write(zserio::BitStreamWriter& _out, zserio::PreWriteAction) const
{
    _out.writeBits(static_cast<uint8_t>(m_value), 3);
}

const char* CloudStorage::toString() const
{
    switch (m_value)
    {
    case TWO_GB:
        return "TWO_GB";
    case FOUR_GB:
        return "FOUR_GB";
    case SIX_GB:
        return "SIX_GB";
    case EIGHT_GB:
        return "EIGHT_GB";
    default:
        return "UNKNOWN";
    }
}

CloudStorage CloudStorage::toEnum(uint8_t rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
        return TWO_GB;

    case UINT8_C(1):
        return FOUR_GB;

    case UINT8_C(2):
        return SIX_GB;

    case UINT8_C(3):
        return EIGHT_GB;

    default:
        throw zserio::CppRuntimeException("Unknown value for enumeration CloudStorage: " +
                zserio::convertToString(rawValue) + "!");
    }
}

} // namespace values
} // namespace skipdict

/**
 * Automatically generated by Zserio C++ extension version 1.0.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include "skipdict/values/Company.h"

namespace skipdict
{
namespace values
{

Company::Company()
{
    m_numEmployees = uint32_t();
}

Company::Company(zserio::BitStreamReader& _in)
{
    read(_in);
}

std::string& Company::getName()
{
    return m_name;
}

const std::string& Company::getName() const
{
    return m_name;
}

void Company::setName(const std::string& name)
{
    m_name = name;
}

std::string& Company::getWebsite()
{
    return m_website;
}

const std::string& Company::getWebsite() const
{
    return m_website;
}

void Company::setWebsite(const std::string& website)
{
    m_website = website;
}

uint32_t Company::getNumEmployees() const
{
    return m_numEmployees;
}

void Company::setNumEmployees(uint32_t numEmployees)
{
    m_numEmployees = numEmployees;
}

size_t Company::bitSizeOf(size_t _bitPosition) const
{
    size_t _endBitPosition = _bitPosition;

    _endBitPosition += zserio::getBitSizeOfString(m_name);
    _endBitPosition += zserio::getBitSizeOfString(m_website);
    _endBitPosition += zserio::getBitSizeOfVarUInt32(m_numEmployees);

    return _endBitPosition - _bitPosition;
}

size_t Company::initializeOffsets(size_t _bitPosition)
{
    size_t _endBitPosition = _bitPosition;

    _endBitPosition += zserio::getBitSizeOfString(m_name);
    _endBitPosition += zserio::getBitSizeOfString(m_website);
    _endBitPosition += zserio::getBitSizeOfVarUInt32(m_numEmployees);

    return _endBitPosition;
}

bool Company::operator==(const Company& _other) const
{
    if (this != &_other)
    {
        return
                (m_name == _other.m_name) &&
                (m_website == _other.m_website) &&
                (m_numEmployees == _other.m_numEmployees);
    }

    return true;
}

int Company::hashCode() const
{
    int _result = zserio::HASH_SEED;

    _result = zserio::calcHashCode(_result, m_name);
    _result = zserio::calcHashCode(_result, m_website);
    _result = zserio::calcHashCode(_result, m_numEmployees);

    return _result;
}

void Company::read(zserio::BitStreamReader& _in)
{
    m_name = (std::string)_in.readString();
    m_website = (std::string)_in.readString();
    m_numEmployees = (uint32_t)_in.readVarUInt32();
}

void Company::write(zserio::BitStreamWriter& _out, zserio::PreWriteAction)
{
    _out.writeString(m_name);
    _out.writeString(m_website);
    _out.writeVarUInt32(m_numEmployees);
}

} // namespace values
} // namespace skipdict

/**
 * Automatically generated by Zserio C++ extension version 1.0.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include "skipdict/values/RockBand.h"

namespace skipdict
{
namespace values
{

RockBand::RockBand()
{
    m_members = uint8_t();
    m_fans = uint64_t();
}

RockBand::RockBand(zserio::BitStreamReader& _in)
{
    read(_in);
}

std::string& RockBand::getName()
{
    return m_name;
}

const std::string& RockBand::getName() const
{
    return m_name;
}

void RockBand::setName(const std::string& name)
{
    m_name = name;
}

uint8_t RockBand::getMembers() const
{
    return m_members;
}

void RockBand::setMembers(uint8_t members)
{
    m_members = members;
}

uint64_t RockBand::getFans() const
{
    return m_fans;
}

void RockBand::setFans(uint64_t fans)
{
    m_fans = fans;
}

size_t RockBand::bitSizeOf(size_t _bitPosition) const
{
    size_t _endBitPosition = _bitPosition;

    _endBitPosition += zserio::getBitSizeOfString(m_name);
    _endBitPosition += UINT8_C(3);
    _endBitPosition += zserio::getBitSizeOfVarUInt64(m_fans);

    return _endBitPosition - _bitPosition;
}

size_t RockBand::initializeOffsets(size_t _bitPosition)
{
    size_t _endBitPosition = _bitPosition;

    _endBitPosition += zserio::getBitSizeOfString(m_name);
    _endBitPosition += UINT8_C(3);
    _endBitPosition += zserio::getBitSizeOfVarUInt64(m_fans);

    return _endBitPosition;
}

bool RockBand::operator==(const RockBand& _other) const
{
    if (this != &_other)
    {
        return
                (m_name == _other.m_name) &&
                (m_members == _other.m_members) &&
                (m_fans == _other.m_fans);
    }

    return true;
}

int RockBand::hashCode() const
{
    int _result = zserio::HASH_SEED;

    _result = zserio::calcHashCode(_result, m_name);
    _result = zserio::calcHashCode(_result, m_members);
    _result = zserio::calcHashCode(_result, m_fans);

    return _result;
}

void RockBand::read(zserio::BitStreamReader& _in)
{
    m_name = (std::string)_in.readString();
    m_members = (uint8_t)_in.readBits(3);
    m_fans = (uint64_t)_in.readVarUInt64();
}

void RockBand::write(zserio::BitStreamWriter& _out, zserio::PreWriteAction)
{
    _out.writeString(m_name);
    _out.writeBits(m_members, 3);
    _out.writeVarUInt64(m_fans);
}

} // namespace values
} // namespace skipdict

/**
 * Automatically generated by Zserio C++ extension version 1.0.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ConstraintException.h>

#include "skipdict/values/BasketballTeam.h"

namespace skipdict
{
namespace values
{

BasketballTeam::BasketballTeam()
{
    m_onField = uint8_t();
}

BasketballTeam::BasketballTeam(zserio::BitStreamReader& _in)
{
    read(_in);
}

uint8_t BasketballTeam::getOnField() const
{
    return m_onField;
}

void BasketballTeam::setOnField(uint8_t onField)
{
    m_onField = onField;
}

zserio::StringArray& BasketballTeam::getPlayersOnField()
{
    return m_PlayersOnField;
}

const zserio::StringArray& BasketballTeam::getPlayersOnField() const
{
    return m_PlayersOnField;
}

void BasketballTeam::setPlayersOnField(const zserio::StringArray& PlayersOnField)
{
    m_PlayersOnField = PlayersOnField;
}

zserio::StringArray& BasketballTeam::getPlayersOnBench()
{
    return m_PlayersOnBench;
}

const zserio::StringArray& BasketballTeam::getPlayersOnBench() const
{
    return m_PlayersOnBench;
}

void BasketballTeam::setPlayersOnBench(const zserio::StringArray& PlayersOnBench)
{
    m_PlayersOnBench = PlayersOnBench;
}

size_t BasketballTeam::bitSizeOf(size_t _bitPosition) const
{
    size_t _endBitPosition = _bitPosition;

    _endBitPosition += UINT8_C(3);
    _endBitPosition += m_PlayersOnField.bitSizeOf(_endBitPosition);
    _endBitPosition += m_PlayersOnBench.bitSizeOf(_endBitPosition, zserio::AutoLength());

    return _endBitPosition - _bitPosition;
}

size_t BasketballTeam::initializeOffsets(size_t _bitPosition)
{
    size_t _endBitPosition = _bitPosition;

    _endBitPosition += UINT8_C(3);
    _endBitPosition = m_PlayersOnField.initializeOffsets(_endBitPosition);
    _endBitPosition = m_PlayersOnBench.initializeOffsets(_endBitPosition, zserio::AutoLength());

    return _endBitPosition;
}

bool BasketballTeam::operator==(const BasketballTeam& _other) const
{
    if (this != &_other)
    {
        return
                (m_onField == _other.m_onField) &&
                (m_PlayersOnField == _other.m_PlayersOnField) &&
                (m_PlayersOnBench == _other.m_PlayersOnBench);
    }

    return true;
}

int BasketballTeam::hashCode() const
{
    int _result = zserio::HASH_SEED;

    _result = zserio::calcHashCode(_result, m_onField);
    _result = zserio::calcHashCode(_result, m_PlayersOnField);
    _result = zserio::calcHashCode(_result, m_PlayersOnBench);

    return _result;
}

void BasketballTeam::read(zserio::BitStreamReader& _in)
{
    m_onField = (uint8_t)_in.readBits(3);
    m_PlayersOnField.read(_in, static_cast<size_t>(getOnField()));
    m_PlayersOnBench.read(_in, zserio::AutoLength());

    checkConstraints();
}

void BasketballTeam::write(zserio::BitStreamWriter& _out, zserio::PreWriteAction)
{
    checkConstraints();
    _out.writeBits(m_onField, 3);
    if (m_PlayersOnField.size() != static_cast<size_t>(getOnField()))
    {
        throw zserio::CppRuntimeException("Write: Wrong array length for field BasketballTeam.PlayersOnField: " +
                zserio::convertToString(m_PlayersOnField.size()) + " != " +
                zserio::convertToString(static_cast<size_t>(getOnField())) + "!");
    }
    m_PlayersOnField.write(_out);
    m_PlayersOnBench.write(_out, zserio::AutoLength());
}

void BasketballTeam::checkConstraints()
{
    if (!(getOnField() <= 5))
        throw zserio::ConstraintException("Constraint violated at BasketballTeam.onField!");
}

} // namespace values
} // namespace skipdict
