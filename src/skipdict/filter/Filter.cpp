/**
 * Automatically generated by Zserio C++ extension version 1.0.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include "skipdict/filter/SkipableDictionary.h"

namespace skipdict
{
namespace filter
{

namespace
{
class _offsetChecker_entries
{
public:
    explicit _offsetChecker_entries(SkipableDictionary& owner) : m_owner(owner) {}

    void checkOffset(size_t _index, size_t byteOffset) const
    {
        if (byteOffset != m_owner.getOffsets().at(_index))
            throw zserio::CppRuntimeException("Wrong offset for field SkipableDictionary.entries: " +
                    zserio::convertToString(byteOffset) + " != " +
                    zserio::convertToString(m_owner.getOffsets().at(_index)) + "!");
    }

private:
    SkipableDictionary& m_owner;
};

class _offsetSetter_entries
{
public:
    explicit _offsetSetter_entries(SkipableDictionary& owner) : m_owner(owner) {}

    void setOffset(size_t _index, size_t byteOffset) const
    {
        const uint32_t _value = (uint32_t)byteOffset;
        m_owner.getOffsets().at(_index) = _value;
    }

private:
    SkipableDictionary& m_owner;
};

class _elementFactory_SkipableDictionary_entries
{
public:
    explicit _elementFactory_SkipableDictionary_entries(SkipableDictionary& owner) : m_owner(owner) {}

    void create(void* storage, zserio::BitStreamReader& _in, size_t _index)
    {
        (void)_index;
        new (storage) skipdict::filter::DictEntry(_in);
    }

private:
    SkipableDictionary& m_owner;
};

} // namespace

SkipableDictionary::SkipableDictionary()
{
}

SkipableDictionary::SkipableDictionary(zserio::BitStreamReader& _in)
{
    read(_in);
}

zserio::UInt32Array& SkipableDictionary::getOffsets()
{
    return m_offsets;
}

const zserio::UInt32Array& SkipableDictionary::getOffsets() const
{
    return m_offsets;
}

void SkipableDictionary::setOffsets(const zserio::UInt32Array& offsets)
{
    m_offsets = offsets;
}

zserio::ObjectArray<skipdict::filter::DictEntry>& SkipableDictionary::getEntries()
{
    return m_entries;
}

const zserio::ObjectArray<skipdict::filter::DictEntry>& SkipableDictionary::getEntries() const
{
    return m_entries;
}

void SkipableDictionary::setEntries(const zserio::ObjectArray<skipdict::filter::DictEntry>& entries)
{
    m_entries = entries;
}

size_t SkipableDictionary::bitSizeOf(size_t _bitPosition) const
{
    size_t _endBitPosition = _bitPosition;

    _endBitPosition += m_offsets.bitSizeOf(_endBitPosition, zserio::AutoLength(), UINT8_C(32));
    if (getEntries().size() > 0)
        _endBitPosition = zserio::alignTo(zserio::NUM_BITS_PER_BYTE, _endBitPosition);
    _endBitPosition += m_entries.bitSizeOf(_endBitPosition, zserio::AutoLength(), zserio::Aligned());

    return _endBitPosition - _bitPosition;
}

size_t SkipableDictionary::initializeOffsets(size_t _bitPosition)
{
    size_t _endBitPosition = _bitPosition;

    _endBitPosition = m_offsets.initializeOffsets(_endBitPosition, zserio::AutoLength(), UINT8_C(32));
    if (getEntries().size() > 0)
        _endBitPosition = zserio::alignTo(zserio::NUM_BITS_PER_BYTE, _endBitPosition);
    _endBitPosition = m_entries.initializeOffsets(_endBitPosition, zserio::AutoLength(), _offsetSetter_entries(*this));

    return _endBitPosition;
}

bool SkipableDictionary::operator==(const SkipableDictionary& _other) const
{
    if (this != &_other)
    {
        return
                (m_offsets == _other.m_offsets) &&
                (m_entries == _other.m_entries);
    }

    return true;
}

int SkipableDictionary::hashCode() const
{
    int _result = zserio::HASH_SEED;

    _result = zserio::calcHashCode(_result, m_offsets);
    _result = zserio::calcHashCode(_result, m_entries);

    return _result;
}

void SkipableDictionary::read(zserio::BitStreamReader& _in)
{
    m_offsets.read(_in, zserio::AutoLength(), UINT8_C(32));
    m_entries.read(_in, zserio::AutoLength(), _elementFactory_SkipableDictionary_entries(*this), _offsetChecker_entries(*this));
}

void SkipableDictionary::write(zserio::BitStreamWriter& _out, zserio::PreWriteAction _preWriteAction)
{
    if ((_preWriteAction & zserio::PRE_WRITE_INITIALIZE_OFFSETS) != 0)
        initializeOffsets(_out.getBitPosition());

    m_offsets.write(_out, zserio::AutoLength(), UINT8_C(32));
    m_entries.write(_out, zserio::AutoLength(), _offsetChecker_entries(*this));
}

} // namespace filter
} // namespace skipdict

/**
 * Automatically generated by Zserio C++ extension version 1.0.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include "skipdict/filter/DictEntry.h"

namespace skipdict
{
namespace filter
{

DictEntry::DictEntry()
{
    m_key = uint32_t();
    m_typeCode = uint8_t();
}

DictEntry::DictEntry(zserio::BitStreamReader& _in)
{
    read(_in);
}

uint32_t DictEntry::getKey() const
{
    return m_key;
}

void DictEntry::setKey(uint32_t key)
{
    m_key = key;
}

uint8_t DictEntry::getTypeCode() const
{
    return m_typeCode;
}

void DictEntry::setTypeCode(uint8_t typeCode)
{
    m_typeCode = typeCode;
}

zserio::UInt8Array& DictEntry::getValue()
{
    return m_value;
}

const zserio::UInt8Array& DictEntry::getValue() const
{
    return m_value;
}

void DictEntry::setValue(const zserio::UInt8Array& value)
{
    m_value = value;
}

size_t DictEntry::bitSizeOf(size_t _bitPosition) const
{
    size_t _endBitPosition = _bitPosition;

    _endBitPosition += zserio::getBitSizeOfVarUInt32(m_key);
    _endBitPosition += UINT8_C(8);
    _endBitPosition += m_value.bitSizeOf(_endBitPosition, zserio::AutoLength(), UINT8_C(8));

    return _endBitPosition - _bitPosition;
}

size_t DictEntry::initializeOffsets(size_t _bitPosition)
{
    size_t _endBitPosition = _bitPosition;

    _endBitPosition += zserio::getBitSizeOfVarUInt32(m_key);
    _endBitPosition += UINT8_C(8);
    _endBitPosition = m_value.initializeOffsets(_endBitPosition, zserio::AutoLength(), UINT8_C(8));

    return _endBitPosition;
}

bool DictEntry::operator==(const DictEntry& _other) const
{
    if (this != &_other)
    {
        return
                (m_key == _other.m_key) &&
                (m_typeCode == _other.m_typeCode) &&
                (m_value == _other.m_value);
    }

    return true;
}

int DictEntry::hashCode() const
{
    int _result = zserio::HASH_SEED;

    _result = zserio::calcHashCode(_result, m_key);
    _result = zserio::calcHashCode(_result, m_typeCode);
    _result = zserio::calcHashCode(_result, m_value);

    return _result;
}

void DictEntry::read(zserio::BitStreamReader& _in)
{
    m_key = (uint32_t)_in.readVarUInt32();
    m_typeCode = (uint8_t)_in.readBits(UINT8_C(8));
    m_value.read(_in, zserio::AutoLength(), UINT8_C(8));
}

void DictEntry::write(zserio::BitStreamWriter& _out, zserio::PreWriteAction)
{
    _out.writeVarUInt32(m_key);
    _out.writeBits(m_typeCode, UINT8_C(8));
    m_value.write(_out, zserio::AutoLength(), UINT8_C(8));
}

} // namespace filter
} // namespace skipdict
