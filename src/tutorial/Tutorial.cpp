/**
 * Automatically generated by Zserio C++ extension version 1.0.
 */

#include <zserio/BitSizeOfCalculator.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/StringConvertUtil.h>

#include "tutorial/Language.h"

namespace tutorial
{

Language::Language() : m_value(static_cast<e_Language>(0))
{
}

Language::Language(e_Language value) : m_value(value)
{
}

Language::Language(zserio::BitStreamReader& _in)
{
    read(_in);
}

Language::operator e_Language() const
{
    return m_value;
}

uint8_t Language::getValue() const
{
    return m_value;
}

size_t Language::bitSizeOf(size_t) const
{
    return UINT8_C(2);
}

size_t Language::initializeOffsets(size_t _bitPosition) const
{
    return _bitPosition + bitSizeOf(_bitPosition);
}

bool Language::operator==(const Language& other) const
{
    return m_value == other.m_value;
}

bool Language::operator==(e_Language other) const
{
    return m_value == other;
}

int Language::hashCode() const
{
    return zserio::calcHashCode(zserio::HASH_SEED, static_cast<uint8_t>(m_value));
}

void Language::read(zserio::BitStreamReader& _in)
{
    m_value = toEnum(_in.readBits(2));
}

void Language::write(zserio::BitStreamWriter& _out, zserio::PreWriteAction) const
{
    _out.writeBits(static_cast<uint8_t>(m_value), 2);
}

const char* Language::toString() const
{
    switch (m_value)
    {
    case CPP:
        return "CPP";
    case JAVA:
        return "JAVA";
    case PYTHON:
        return "PYTHON";
    case JS:
        return "JS";
    default:
        return "UNKNOWN";
    }
}

Language Language::toEnum(uint8_t rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
        return CPP;

    case UINT8_C(1):
        return JAVA;

    case UINT8_C(2):
        return PYTHON;

    case UINT8_C(3):
        return JS;

    default:
        throw zserio::CppRuntimeException("Unknown value for enumeration Language: " +
                zserio::convertToString(rawValue) + "!");
    }
}

} // namespace tutorial

/**
 * Automatically generated by Zserio C++ extension version 1.0.
 */

#include <zserio/BitSizeOfCalculator.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/StringConvertUtil.h>

#include "tutorial/Role.h"

namespace tutorial
{

Role::Role() : m_value(static_cast<e_Role>(0))
{
}

Role::Role(e_Role value) : m_value(value)
{
}

Role::Role(zserio::BitStreamReader& _in)
{
    read(_in);
}

Role::operator e_Role() const
{
    return m_value;
}

uint8_t Role::getValue() const
{
    return m_value;
}

size_t Role::bitSizeOf(size_t) const
{
    return UINT8_C(8);
}

size_t Role::initializeOffsets(size_t _bitPosition) const
{
    return _bitPosition + bitSizeOf(_bitPosition);
}

bool Role::operator==(const Role& other) const
{
    return m_value == other.m_value;
}

bool Role::operator==(e_Role other) const
{
    return m_value == other;
}

int Role::hashCode() const
{
    return zserio::calcHashCode(zserio::HASH_SEED, static_cast<uint8_t>(m_value));
}

void Role::read(zserio::BitStreamReader& _in)
{
    m_value = toEnum(_in.readBits(UINT8_C(8)));
}

void Role::write(zserio::BitStreamWriter& _out, zserio::PreWriteAction) const
{
    _out.writeBits(static_cast<uint8_t>(m_value), UINT8_C(8));
}

const char* Role::toString() const
{
    switch (m_value)
    {
    case DEVELOPER:
        return "DEVELOPER";
    case TEAM_LEAD:
        return "TEAM_LEAD";
    case CTO:
        return "CTO";
    default:
        return "UNKNOWN";
    }
}

Role Role::toEnum(uint8_t rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
        return DEVELOPER;

    case UINT8_C(1):
        return TEAM_LEAD;

    case UINT8_C(2):
        return CTO;

    default:
        throw zserio::CppRuntimeException("Unknown value for enumeration Role: " +
                zserio::convertToString(rawValue) + "!");
    }
}

} // namespace tutorial

/**
 * Automatically generated by Zserio C++ extension version 1.0.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ConstraintException.h>

#include "tutorial/Employee.h"

namespace tutorial
{

namespace
{

class _elementFactory_Employee_skills
{
public:
    explicit _elementFactory_Employee_skills(Employee& owner) : m_owner(owner) {}

    void create(void* storage, zserio::BitStreamReader& _in, size_t _index)
    {
        (void)_index;
        new (storage) tutorial::Experience(_in);
    }

private:
    Employee& m_owner;
};

} // namespace

Employee::Employee()
{
    m_age = uint8_t();
    m_salary = uint16_t();
    m_role = tutorial::Role();
}

Employee::Employee(zserio::BitStreamReader& _in)
{
    read(_in);
}

uint8_t Employee::getAge() const
{
    return m_age;
}

void Employee::setAge(uint8_t age)
{
    m_age = age;
}

std::string& Employee::getName()
{
    return m_name;
}

const std::string& Employee::getName() const
{
    return m_name;
}

void Employee::setName(const std::string& name)
{
    m_name = name;
}

uint16_t Employee::getSalary() const
{
    return m_salary;
}

void Employee::setSalary(uint16_t salary)
{
    m_salary = salary;
}

uint16_t Employee::getBonus() const
{
    return m_bonus.get();
}

void Employee::setBonus(uint16_t bonus)
{
    m_bonus.set(bonus);
}

bool Employee::hasBonus() const
{
    return (m_bonus.isSet());
}

tutorial::Role Employee::getRole() const
{
    return m_role;
}

void Employee::setRole(tutorial::Role role)
{
    m_role = role;
}

zserio::ObjectArray<tutorial::Experience>& Employee::getSkills()
{
    return m_skills.get();
}

const zserio::ObjectArray<tutorial::Experience>& Employee::getSkills() const
{
    return m_skills.get();
}

void Employee::setSkills(const zserio::ObjectArray<tutorial::Experience>& skills)
{
    m_skills.set(skills);
}

bool Employee::hasSkills() const
{
    return (getRole() == tutorial::Role::DEVELOPER);
}

size_t Employee::bitSizeOf(size_t _bitPosition) const
{
    size_t _endBitPosition = _bitPosition;

    _endBitPosition += UINT8_C(8);
    _endBitPosition += zserio::getBitSizeOfString(m_name);
    _endBitPosition += UINT8_C(16);
    _endBitPosition += 1;
    if (m_bonus.isSet())
    {
        _endBitPosition += UINT8_C(16);
    }
    _endBitPosition += m_role.bitSizeOf(_endBitPosition);
    if (getRole() == tutorial::Role::DEVELOPER)
    {
        _endBitPosition += m_skills.get().bitSizeOf(_endBitPosition, zserio::AutoLength());
    }

    return _endBitPosition - _bitPosition;
}

size_t Employee::initializeOffsets(size_t _bitPosition)
{
    size_t _endBitPosition = _bitPosition;

    _endBitPosition += UINT8_C(8);
    _endBitPosition += zserio::getBitSizeOfString(m_name);
    _endBitPosition += UINT8_C(16);
    _endBitPosition += 1;
    if (m_bonus.isSet())
    {
        _endBitPosition += UINT8_C(16);
    }
    _endBitPosition = m_role.initializeOffsets(_endBitPosition);
    if (getRole() == tutorial::Role::DEVELOPER)
    {
        _endBitPosition = m_skills.get().initializeOffsets(_endBitPosition, zserio::AutoLength());
    }

    return _endBitPosition;
}

bool Employee::operator==(const Employee& _other) const
{
    if (this != &_other)
    {
        return
                (m_age == _other.m_age) &&
                (m_name == _other.m_name) &&
                (m_salary == _other.m_salary) &&
                (m_bonus == _other.m_bonus) &&
                (m_role == _other.m_role) &&
                (!(getRole() == tutorial::Role::DEVELOPER) || m_skills == _other.m_skills);
    }

    return true;
}

int Employee::hashCode() const
{
    int _result = zserio::HASH_SEED;

    _result = zserio::calcHashCode(_result, m_age);
    _result = zserio::calcHashCode(_result, m_name);
    _result = zserio::calcHashCode(_result, m_salary);
    _result = zserio::calcHashCode(_result, m_bonus);
    _result = zserio::calcHashCode(_result, m_role);
    if (getRole() == tutorial::Role::DEVELOPER)
        _result = zserio::calcHashCode(_result, m_skills);

    return _result;
}

void Employee::read(zserio::BitStreamReader& _in)
{
    m_age = (uint8_t)_in.readBits(UINT8_C(8));
    m_name = (std::string)_in.readString();
    m_salary = (uint16_t)_in.readBits(UINT8_C(16));
    if (_in.readBool())
    {
        m_bonus.reset(new (m_bonus.getResetStorage())
                uint16_t(_in.readBits(UINT8_C(16))));
    }
    m_role = (tutorial::Role)_in;
    if (getRole() == tutorial::Role::DEVELOPER)
    {
        m_skills.reset(new (m_skills.getResetStorage())
                zserio::ObjectArray<tutorial::Experience>(_in, zserio::AutoLength(), _elementFactory_Employee_skills(*this)));
    }

    checkConstraints();
}

void Employee::write(zserio::BitStreamWriter& _out, zserio::PreWriteAction)
{
    checkConstraints();
    _out.writeBits(m_age, UINT8_C(8));
    _out.writeString(m_name);
    _out.writeBits(m_salary, UINT8_C(16));
    if (m_bonus.isSet())
    {
        _out.writeBool(true);
        _out.writeBits(m_bonus.get(), UINT8_C(16));
    }
    else
    {
        _out.writeBool(false);
    }
    m_role.write(_out, zserio::NO_PRE_WRITE_ACTION);
    if (getRole() == tutorial::Role::DEVELOPER)
    {
        m_skills.get().write(_out, zserio::AutoLength());
    }
}

void Employee::checkConstraints()
{
    if (!(getAge() <= 65))
        throw zserio::ConstraintException("Constraint violated at Employee.age!");
}

} // namespace tutorial

/**
 * Automatically generated by Zserio C++ extension version 1.0.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include "tutorial/Experience.h"

namespace tutorial
{

Experience::Experience()
{
    m_yearsOfExperience = uint8_t();
    m_programmingLanguage = tutorial::Language();
}

Experience::Experience(zserio::BitStreamReader& _in)
{
    read(_in);
}

uint8_t Experience::getYearsOfExperience() const
{
    return m_yearsOfExperience;
}

void Experience::setYearsOfExperience(uint8_t yearsOfExperience)
{
    m_yearsOfExperience = yearsOfExperience;
}

tutorial::Language Experience::getProgrammingLanguage() const
{
    return m_programmingLanguage;
}

void Experience::setProgrammingLanguage(tutorial::Language programmingLanguage)
{
    m_programmingLanguage = programmingLanguage;
}

size_t Experience::bitSizeOf(size_t _bitPosition) const
{
    size_t _endBitPosition = _bitPosition;

    _endBitPosition += UINT8_C(6);
    _endBitPosition += m_programmingLanguage.bitSizeOf(_endBitPosition);

    return _endBitPosition - _bitPosition;
}

size_t Experience::initializeOffsets(size_t _bitPosition)
{
    size_t _endBitPosition = _bitPosition;

    _endBitPosition += UINT8_C(6);
    _endBitPosition = m_programmingLanguage.initializeOffsets(_endBitPosition);

    return _endBitPosition;
}

bool Experience::operator==(const Experience& _other) const
{
    if (this != &_other)
    {
        return
                (m_yearsOfExperience == _other.m_yearsOfExperience) &&
                (m_programmingLanguage == _other.m_programmingLanguage);
    }

    return true;
}

int Experience::hashCode() const
{
    int _result = zserio::HASH_SEED;

    _result = zserio::calcHashCode(_result, m_yearsOfExperience);
    _result = zserio::calcHashCode(_result, m_programmingLanguage);

    return _result;
}

void Experience::read(zserio::BitStreamReader& _in)
{
    m_yearsOfExperience = (uint8_t)_in.readBits(6);
    m_programmingLanguage = (tutorial::Language)_in;
}

void Experience::write(zserio::BitStreamWriter& _out, zserio::PreWriteAction)
{
    _out.writeBits(m_yearsOfExperience, 6);
    m_programmingLanguage.write(_out, zserio::NO_PRE_WRITE_ACTION);
}

} // namespace tutorial
